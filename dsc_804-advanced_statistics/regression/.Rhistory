)%>%
# Optional: drop columns unnecessary columns (granular & time-based)
select(-order, -pid)
ames_clean <- ames %>%
mutate(
# Group 1: NA really means "None" (categorical)
across(
c(alley, pool_qc, fence, misc_feature,
fireplace_qu, garage_type, garage_finish, garage_qual, garage_cond,
bsmt_qual, bsmt_cond, bsmt_exposure, bsmt_fin_type_1, bsmt_fin_type_2,
mas_vnr_type),
~ replace_na(., "None") %>% as.factor()
),
# Group 2: NA means "no feature" → 0 (numeric)
across(
c(garage_cars, garage_area,
bsmt_full_bath, bsmt_half_bath,
bsmt_fin_sf_1, bsmt_fin_sf_2, bsmt_unf_sf, total_bsmt_sf,
mas_vnr_area),
~ replace_na(., 0)
),
# Garage Yr Blt, same as Year Built if missing (or 0)
garage_yr_blt = coalesce(garage_yr_blt, year_built),
# Electrical → very few missing → just mode
electrical = replace_na(electrical, "SBrkr") %>% as.factor(),
# Year remod/add, if no remodel, = year built
year_remod_add = if_else(year_remod_add == 1950 & year_built < 1950,
year_built,
year_remod_add)
)%>%
# Optional: drop columns unnecessary columns (granular & time-based)
select(-order, -pid)
# ─── 3. Final check ─────────────────────────────────────────────
colSums(is.na(ames_clean)) %>%
sort(decreasing = TRUE) %>%
head(15)
#lot_frontage missing values using median-imputation
ames_clean_df <- ames_clean %>%
lot_frontage[is.na(lot_frontage)] <- median(lot_frontage, na.rm = TRUE)
#lot_frontage missing values using median-imputation
ames_clean
ames_clean <- ames %>%
mutate(
# Group 1: NA really means "None" (categorical)
across(
c(alley, pool_qc, fence, misc_feature,
fireplace_qu, garage_type, garage_finish, garage_qual, garage_cond,
bsmt_qual, bsmt_cond, bsmt_exposure, bsmt_fin_type_1, bsmt_fin_type_2,
mas_vnr_type),
~ replace_na(., "None") %>% as.factor()
),
# Group 2: NA means "no feature" → 0 (numeric)
across(
c(garage_cars, garage_area,
bsmt_full_bath, bsmt_half_bath,
bsmt_fin_sf_1, bsmt_fin_sf_2, bsmt_unf_sf, total_bsmt_sf,
mas_vnr_area),
~ replace_na(., 0)
),
#
mutate(lot_frontage = replace_na(lot_frontage, median(lot_frontage, na.rm = TRUE))),
# Garage Yr Blt, same as Year Built if missing (or 0)
garage_yr_blt = coalesce(garage_yr_blt, year_built),
# Electrical → very few missing → just mode
electrical = replace_na(electrical, "SBrkr") %>% as.factor(),
# Year remod/add, if no remodel, = year built
year_remod_add = if_else(year_remod_add == 1950 & year_built < 1950,
year_built,
year_remod_add)
)%>%
# Optional: drop columns unnecessary columns (granular & time-based)
select(-order, -pid)
ames_clean <- ames %>%
mutate(
# Group 1: NA really means "None" (categorical)
across(
c(alley, pool_qc, fence, misc_feature,
fireplace_qu, garage_type, garage_finish, garage_qual, garage_cond,
bsmt_qual, bsmt_cond, bsmt_exposure, bsmt_fin_type_1, bsmt_fin_type_2,
mas_vnr_type),
~ replace_na(., "None") %>% as.factor()
),
# Group 2: NA means "no feature" → 0 (numeric)
across(
c(garage_cars, garage_area,
bsmt_full_bath, bsmt_half_bath,
bsmt_fin_sf_1, bsmt_fin_sf_2, bsmt_unf_sf, total_bsmt_sf,
mas_vnr_area),
~ replace_na(., 0)
),
#
lot_frontage = replace_na(lot_frontage, median(lot_frontage, na.rm = TRUE)),
# Garage Yr Blt, same as Year Built if missing (or 0)
garage_yr_blt = coalesce(garage_yr_blt, year_built),
# Electrical → very few missing → just mode
electrical = replace_na(electrical, "SBrkr") %>% as.factor(),
# Year remod/add, if no remodel, = year built
year_remod_add = if_else(year_remod_add == 1950 & year_built < 1950,
year_built,
year_remod_add)
)%>%
# Optional: drop columns unnecessary columns (granular & time-based)
select(-order, -pid)
# ─── 3. Final check ─────────────────────────────────────────────
colSums(is.na(ames_clean)) %>%
sort(decreasing = TRUE) %>%
head(15)
ames_clean <- ames %>%
mutate(
# NA really means "None" (categorical)
across(
c(alley, pool_qc, fence, misc_feature,
fireplace_qu, garage_type, garage_finish, garage_qual, garage_cond,
bsmt_qual, bsmt_cond, bsmt_exposure, bsmt_fin_type_1, bsmt_fin_type_2,
mas_vnr_type),
~ replace_na(., "None") %>% as.factor()
),
# NA means "no feature", 0 (numeric)
across(
c(garage_cars, garage_area,
bsmt_full_bath, bsmt_half_bath,
bsmt_fin_sf_1, bsmt_fin_sf_2, bsmt_unf_sf, total_bsmt_sf,
mas_vnr_area),
~ replace_na(., 0)
),
# using median-imputation for lot_frontage
lot_frontage = replace_na(lot_frontage, median(lot_frontage, na.rm = TRUE)),
# Garage Yr Blt, same as Year Built if missing (or 0)
garage_yr_blt = coalesce(garage_yr_blt, year_built),
# Electrical → very few missing → just mode
electrical = replace_na(electrical, "SBrkr") %>% as.factor(),
# Year remod/add, if no remodel, = year built
year_remod_add = if_else(year_remod_add == 1950 & year_built < 1950,
year_built,
year_remod_add)
)%>%
# Optional: drop columns unnecessary columns (granular & time-based)
select(-order, -pid)
# ─── 3. Final check ─────────────────────────────────────────────
colSums(is.na(ames_clean))
install.packages("MASS")
library(MASS)
lm(sale_price ~ ., ames_clean) %>%
step(direction = "backward", trace = 0) %>%
summary()
library(MASS)
model1 <- lm(sale_price ~ ., ames_clean) %>%
step(direction = "backward", trace = 0) %>%
summary()
model1
# Quick diagnostic checks
par(mfrow = c(2,2))
plot(model1)           # classic 4 diagnostic plots
# Quick diagnostic checks
plot(model1)           # classic 4 diagnostic plots
# Quick diagnostic checks
model1           # classic 4 diagnostic plots
# Quick diagnostic checks
vif(model1)           # classic 4 diagnostic plots
# Quick diagnostic checks
mean_residuals <- mean(residuals(model1))
# Quick diagnostic checks
mean_residuals <- mean(residuals(model1))
cat("Mean of residuals: ", mean_residuals, "\n")
# Quick diagnostic checks
mean_residuals <- mean(residuals(model1))
cat("Mean of residuals: ", mean_residuals)
# Quick diagnostic checks
mean_residuals <- mean(residuals(model1))
cat("Mean of residuals: ", mean_residuals)
# 2. Homoscedasticity (Constant Variance)
cat("Homoscedasticity Assumption")
# Visual check
par(mfrow = c(1, 2))
plot(fitted(model1), residuals(model1),
main = "Residuals vs Fitted Values",
xlab = "Fitted Values", ylab = "Residuals")
plot(model1)
library(MASS)
attach(ames_clean)
model <- lm(sale_price ~ .) %>%
step(direction = "backward", trace = 0) %>%
summary()
library(MASS)
attach(ames_clean)
model <- lm(sale_price ~ ., data = ames_clean) %>%
step(direction = "backward", trace = 0) %>%
summary()
model
plot(model)
mreg <- lm(sale_price ~ ., data = ames_clean)
stepwise <- step(mreg, direction = "backward")
mreg <- lm(sale_price ~ ., data = ames_clean)
stepwise <- step(mreg, direction = "backward", trace = 0)
summary(stepwise)
avPlot(stepwise)
plot(stepwise)
plot(stepwise)
plot(stepwise)
# Quick diagnostic checks
mean_residuals <- mean(residuals(model1))
cat("Mean of residuals: ", mean_residuals)
plot(stepwise)
plot(fitted(stepwise), residuals(stepwise),
main = "Residuals vs Fitted Values",
xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, col = "red", lty = 2)
# Scale-Location plot
plot(fitted(stepwise), sqrt(abs(rstandard(stepwise))),
main = "Scale-Location Plot",
xlab = "Fitted Values", ylab = "√|Standardized Residuals|")
lines(lowess(fitted(stepwise), sqrt(abs(rstandard(stepwise)))), col = "red")
# Scale-Location plot
plot(fitted(stepwise), sqrt(abs(rstandard(stepwise))),
main = "Scale-Location Plot",
xlab = "Fitted Values", ylab = "Standardized Residuals")
lines(lowess(fitted(stepwise), sqrt(abs(rstandard(stepwise)))), col = "red")
# Scale-Location plot
plot(fitted(stepwise), sqrt(abs(rstandard(stepwise))),
main = "Scale-Location Plot",
xlab = "Fitted Values", ylab = "Standardized Residuals")
lines(lowess(fitted(stepwise), sqrt(abs(rstandard(stepwise)))), col = "red")
# Formal tests for heteroscedasticity
bp_test <- bptest(stepwise)
install.packages("lmtest")
# Scale-Location plot
plot(fitted(stepwise), sqrt(abs(rstandard(stepwise))),
main = "Scale-Location Plot",
xlab = "Fitted Values", ylab = "Standardized Residuals")
lines(lowess(fitted(stepwise), sqrt(abs(rstandard(stepwise)))), col = "red")
# Formal tests for heteroscedasticity
library(lmtest)
bp_test <- bptest(stepwise)
cat("Breusch-Pagan test for heteroscedasticity:\n")
print(bp_test)
# Scale-Location plot
plot(fitted(stepwise), sqrt(abs(rstandard(stepwise))),
main = "Scale-Location Plot",
xlab = "Fitted Values", ylab = "Standardized Residuals")
lines(lowess(fitted(stepwise), sqrt(abs(rstandard(stepwise)))), col = "red")
# Formal tests for heteroscedasticity
library(lmtest)
bp_test <- bptest(stepwise)
cat("Breusch-Pagan test for heteroscedasticity:\n")
print(bp_test)
# 3. Normality of Residuals
cat("Normality of Residuals Assumption")
# Visual check
par(mfrow = c(1, 2))
hist(residuals(stepwise),
main = "Histogram of Residuals",
xlab = "Residuals", freq = FALSE)
lines(density(residuals(stepwise)), col = "blue", lwd = 2)
curve(dnorm(x, mean = mean(residuals(stepwise)), sd = sd(residuals(stepwise))),
add = TRUE, col = "red", lty = 2, lwd = 2)
legend("topright", c("Density", "Normal"),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Q-Q plot
qqnorm(residuals(stepwise))
qqline(residuals(stepwise), col = "red")
# Formal tests for normality
ks_test <- lillie.test(residuals(stepwise))
install.packages("nortest")
# 3. Normality of Residuals
cat("Normality of Residuals Assumption")
# Visual check
par(mfrow = c(1, 2))
hist(residuals(stepwise),
main = "Histogram of Residuals",
xlab = "Residuals", freq = FALSE)
lines(density(residuals(stepwise)), col = "blue", lwd = 2)
curve(dnorm(x, mean = mean(residuals(stepwise)), sd = sd(residuals(stepwise))),
add = TRUE, col = "red", lty = 2, lwd = 2)
legend("topright", c("Density", "Normal"),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Q-Q plot
qqnorm(residuals(stepwise))
qqline(residuals(stepwise), col = "red")
# Formal tests for normality
library(nortest)
ks_test <- lillie.test(residuals(stepwise))
cat("Kolmogorov-Smirnov test for normality:\n")
print(ks_test)
# Additional modern checks (recommended)
check_model(stepwise)    # from performance package - very informative!
# 8. Check multicollinearity (VIF)
vif(stepwise)            # values > 5–9 are concerning, warrants investigation, >10 usually bad
alias(stepwise)
corr_matrix <- cor(ames_clean[, c("sale_price", "ms_sub_class", "lot_frontage", "lot_area", "street", "land_contour", "lot_config", "land_slope", "neighborhood", "condition_1", "condition_2", "overall_qual", "overall_cond", "year_built", "year_remod_add", "roof_matl", "exterior_1st", "mas_vnr_type", "mas_vnr_area", "exter_qual", "bsmt_qual", "bsmt_exposure", "bsmt_fin_type_1", "bsmt_fin_sf_1", "bsmt_fin_type_2", "bsmt_fin_sf_2", "bsmt_unf_sf", "heating_qc", "central_air", "x1st_flr_sf", "x2nd_flr_sf", "low_qual_fin_sf", "bsmt_full_bath", "full_bath", "half_bath", "bedroom_abv_gr", "kitchen_abv_gr", "kitchen_qual", "tot_rms_abv_grd", "functional", "fireplaces", "fireplace_qu", "garage_finish", "garage_cars", "garage_area", "garage_qual", "garage_cond", "wood_deck_sf", "screen_porch", "pool_qc", "misc_feature", "yr_sold", "sale_condition")])
corr_matrix <- cor(ames_clean["sale_price", c("ms_sub_class", "lot_frontage", "lot_area", "street", "land_contour", "lot_config", "land_slope", "neighborhood", "condition_1", "condition_2", "overall_qual", "overall_cond", "year_built", "year_remod_add", "roof_matl", "exterior_1st", "mas_vnr_type", "mas_vnr_area", "exter_qual", "bsmt_qual", "bsmt_exposure", "bsmt_fin_type_1", "bsmt_fin_sf_1", "bsmt_fin_type_2", "bsmt_fin_sf_2", "bsmt_unf_sf", "heating_qc", "central_air", "x1st_flr_sf", "x2nd_flr_sf", "low_qual_fin_sf", "bsmt_full_bath", "full_bath", "half_bath", "bedroom_abv_gr", "kitchen_abv_gr", "kitchen_qual", "tot_rms_abv_grd", "functional", "fireplaces", "fireplace_qu", "garage_finish", "garage_cars", "garage_area", "garage_qual", "garage_cond", "wood_deck_sf", "screen_porch", "pool_qc", "misc_feature", "yr_sold", "sale_condition")])
#alias(stepwise)
ld.vars <- attributes(alias(stepwise)$Complete)$dimnames[[1]]
#alias(stepwise)
ld.vars <- attributes(alias(stepwise)$Complete)$dimnames[[1]]
#remove the linearly dependent variables variables
formula.new <- as.formula(
paste(
paste(deparse(formula), collapse=""),
paste(ld.vars, collapse="-"),
sep="-"
)
)
#alias(stepwise)
ld.vars <- attributes(alias(stepwise)$Complete)$dimnames[[1]]
#remove the linearly dependent variables variables
formula.new <- as.formula(
paste(
paste(deparse(mreg), collapse=""),
paste(ld.vars, collapse="-"),
sep="-"
)
)
#alias(stepwise)
ld.vars <- attributes(alias(stepwise)$Complete)$dimnames[[1]]
#remove the linearly dependent variables variables
formula.new <- as.formula(
paste(
paste(deparse(stepwise), collapse=""),
paste(ld.vars, collapse="-"),
sep="-"
)
)
alias(stepwise)
m1 <- alias(stepwise)
#run model again
fit.new <-lm(m1)
m1 <- attributes(alias(stepwise)$Complete)$dimnames[[1]]
#run model again
fit.new <- lm(m1)
library(av)
library(tesseract)
library(stringr)
solve_video_alphabet_puzzle <- function(video_path) {
# --- Step 1: Extract Text from Video ---
# Create a temporary directory for frames
tmp_dir <- tempdir()
# Extract one frame per second to avoid redundant processing
av_video_images(video_path, destdir = tmp_dir, format = "png", fps = 1)
frames <- list.files(tmp_dir, pattern = "\\.png$", full.names = TRUE)
# Initialize OCR engine
eng <- tesseract("eng") # Or use a custom pattern if symbols are non-standard
# Extract text from each frame
raw_text <- sapply(frames, function(img) {
ocr(img, engine = eng)
})
# Clean the extracted text: split into words, remove whitespace and empty entries
words <- unlist(strsplit(raw_text, "\\s+"))
words <- words[words != ""]
words <- tolower(unique(words)) # Assume no capitalization per rules
cat("Extracted Dictionary Words:\n", paste(words, collapse = ", "), "\n\n")
# --- Step 2: Build the Alphabetical Logic ---
all_chars <- unique(unlist(strsplit(words, "")))
adj <- setNames(vector("list", length(all_chars)), all_chars)
in_degree <- setNames(numeric(length(all_chars)), all_chars)
for (i in 1:(length(words) - 1)) {
w1 <- unlist(strsplit(words[i], ""))
w2 <- unlist(strsplit(words[i+1], ""))
len <- min(length(w1), length(w2))
for (j in 1:len) {
if (w1[j] != w2[j]) {
if (!(w2[j] %in% adj[[w1[j]]])) {
adj[[w1[j]]] <- c(adj[[w1[j]]], w2[j])
in_degree[w2[j]] <- in_degree[w2[j]] + 1
}
break
}
}
}
# --- Step 3: Topological Sort (Kahn's) ---
queue <- names(in_degree[in_degree == 0])
result <- c()
while (length(queue) > 0) {
u <- queue[1]; queue <- queue[-1]
result <- c(result, u)
for (v in adj[[u]]) {
in_degree[v] <- in_degree[v] - 1
if (in_degree[v] == 0) queue <- c(queue, v)
}
}
if (length(result) < length(all_chars)) {
stop("Contradiction found: The civilization's alphabet has a cycle!")
}
return(paste(result, collapse = " > "))
}
# Usage:
final_order <- solve_video_alphabet_puzzle("path/to/your/file.mov")
# Usage:
final_order <- solve_video_alphabet_puzzle("/Users/bett/downloads/vecteezy_looping-matrix-style-cyrillic-alphabet-code-rain-effect_6102172.mov")
# install.packages("igraph")
library(igraph)
solve_video_alphabet_puzzle_robust <- function(words) {
# 1. Clean words (remove very short/noisy strings)
words <- words[nchar(words) > 0]
all_chars <- unique(unlist(strsplit(words, "")))
# 2. Build edges
edges <- c()
for (i in 1:(length(words) - 1)) {
w1 <- unlist(strsplit(words[i], ""))
w2 <- unlist(strsplit(words[i+1], ""))
len <- min(length(w1), length(w2))
# Prefix check
if (length(w1) > length(w2) && all(w1[1:len] == w2[1:len])) {
cat("Warning: Prefix violation at", words[i], "and", words[i+1], "\n")
next
}
for (j in 1:len) {
if (w1[j] != w2[j]) {
edges <- c(edges, w1[j], w2[j])
break
}
}
}
# 3. Create Graph
g <- graph(edges, isolates = all_chars, directed = TRUE)
# 4. Check for Cycles and Debug
if (!is_dag(g)) {
cat("Cycle detected! The problematic characters are likely part of this loop:\n")
# This finds the first cycle it can find
print(is_dag(g, details = TRUE)$cycle)
# Optional: Plot the graph to see the mess
plot(g, edge.arrow.size=.5, vertex.color="gold")
return(NULL)
}
# 5. Topological Sort
order_idx <- topo_sort(g)
return(names(order_idx))
}
# Apply to your extracted words
final_alphabet <- solve_video_alphabet_puzzle_robust(words)
solve_circular_alphabet <- function(words) {
# 1. Clean and identify unique characters
words <- tolower(unique(words[nchar(words) > 0]))
all_chars <- unique(unlist(strsplit(words, "")))
# 2. Build the graph edges
edges_list <- list()
for (i in 1:(length(words) - 1)) {
w1 <- unlist(strsplit(words[i], ""))
w2 <- unlist(strsplit(words[i+1], ""))
len <- min(length(w1), length(w2))
for (j in 1:len) {
if (w1[j] != w2[j]) {
edges_list[[length(edges_list) + 1]] <- c(w1[j], w2[j])
break
}
}
}
# Convert list to a flat vector for igraph
edges_vec <- unlist(edges_list)
g <- graph(edges_vec, isolates = all_chars, directed = TRUE)
# 3. Handle the Cycle
if (!is_dag(g)) {
cat("Detected circular alphabet. Finding the 'wrap-around' edge...\n")
# We find the Feedback Arc Set: the minimum edges to remove to make it a DAG
# In a simple alphabet loop, this is usually the edge connecting 'Z' back to 'A'
fas <- feedback_arc_set(g)
# Remove the feedback edges to 'break' the circle
g_linear <- delete_edges(g, fas)
# 4. Topological Sort on the broken graph
order_idx <- topo_sort(g_linear)
final_order <- names(order_idx)
cat("Calculated Order (Loop Broken):\n")
return(paste(final_order, collapse = " -> "))
} else {
# If no cycle was found after all
return(paste(names(topo_sort(g)), collapse = " -> "))
}
}
# Example use with your extracted words
result <- solve_circular_alphabet(extracted_words)
print(result)
library(igraph)
solve_circular_alphabet <- function(words) {
# 1. Clean and identify unique characters
words <- tolower(unique(words[nchar(words) > 0]))
all_chars <- unique(unlist(strsplit(words, "")))
# 2. Build the graph edges
edges_list <- list()
for (i in 1:(length(words) - 1)) {
w1 <- unlist(strsplit(words[i], ""))
w2 <- unlist(strsplit(words[i+1], ""))
len <- min(length(w1), length(w2))
for (j in 1:len) {
if (w1[j] != w2[j]) {
edges_list[[length(edges_list) + 1]] <- c(w1[j], w2[j])
break
}
}
}
# Convert list to a flat vector for igraph
edges_vec <- unlist(edges_list)
g <- graph(edges_vec, isolates = all_chars, directed = TRUE)
# 3. Handle the Cycle
if (!is_dag(g)) {
cat("Detected circular alphabet. Finding the 'wrap-around' edge...\n")
# We find the Feedback Arc Set: the minimum edges to remove to make it a DAG
# In a simple alphabet loop, this is usually the edge connecting 'Z' back to 'A'
fas <- feedback_arc_set(g)
# Remove the feedback edges to 'break' the circle
g_linear <- delete_edges(g, fas)
# 4. Topological Sort on the broken graph
order_idx <- topo_sort(g_linear)
final_order <- names(order_idx)
cat("Calculated Order (Loop Broken):\n")
return(paste(final_order, collapse = " -> "))
} else {
# If no cycle was found after all
return(paste(names(topo_sort(g)), collapse = " -> "))
}
}
# Example use with your extracted words
result <- solve_circular_alphabet("/Users/bett/downloads/vecteezy_looping-matrix-style-cyrillic-alphabet-code-rain-effect_6102172.mov")
print(result)
